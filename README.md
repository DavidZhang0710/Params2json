# Params2json
[![badge](https://img.shields.io/badge/license-MIT-blue)](https://github.com/DavidZhang0710/Params2json/blob/main/LICENSE)

A Parameter-to-JSON module based on jsoncpp, to facilitate tracking for API calls or transferring parameters as binary data. It supports multiple platforms.

## Project Introduction
A Parameter-to-JSON module based on jsoncpp, to facilitate tracking for API calls or transferring parameters as binary data. It supports multiple platforms.

Due to the special features of C++, there is no complete reflection mechanism, resulting in the loss of runtime information. It was only in the C++17 standard that began to support for struct serialization , and still many details such as member names were optimized and inaccessible at compile time.

However, If you want to introduce a reflection mechanism in a C++ project to restore such information, it often requires the inclusion of large third-party libraries like Boost, resulting in significant increases in package size. This project provides a simpler, static, non-intrusive serialization solution that allows for custom serialization of complex parameters such as structs with minimal modifications to the project's source code.

This project utilizes [open-source-parsers/jsoncpp](https://github.com/open-source-parsers/jsoncpp) for extensive adaptability，if want to use other json libraries，such the lighter and more efficient [nlohmann/json](https://github.com/nlohmann/json)，only few refactors need to be done.

## Project Requirement

c++>=11

jsoncpp>=1.9.4

cmake>=3.12

## Quick Start

1. Download this repo.

   ```bash
   git clone https://github.com/DavidZhang0710/Params2json.git
   ```

2. Compile.

   ```bash
   cd ./Params2json
   mkdir build
   cd ./build
   cmake ..
   cmake --build .
   ```

   During the execution of cmake, the jsoncpp static library will be automatically downloaded, compiled, and linked.

3. 
   Run.

   After executing the above command, the executable file Params2json will be generated. Running it will display the execution result of `src/example.cpp`.

## Usage

#### All definied attributions

```c++
namespace params2json {
    //T-type to json method
    template <typename T>
		Json::Value toJson(const T& value);
    //Define a structure funcname_s corresponding to the function, place it in a header file (.h).
    STRUCT_WITH_XMEMBER(funcname, typename_0, paramname_0,...)
    //Implementation of the toJson function for the above structure, place it in an implementation file (.cc).
    IMPL_STRUCT_WITH_XMEMBER(funcname, typename_0, paramname_0,...)
    //In conjunction with the above structure, generate a JSON string for the parameters.
    template <typename T>
    std::string make_message(const T& t);
}
```



- #### Add funtion marco

  For function like`void func (typename_0, param_0, typename_1, param_1)`，you can add definitions as below.

  ```c++
  STRUCT_WITH_2MEMBER(func, typename_0, param_0, typename_1, param_1)
  IMPL_STRUCT_WITH_2MEMBER(func, typename_0, param_0, typename_1, param_1)
  ```

  Then you can use ***func_s*** and ***make_message*** generated by the marco to generate JSON string.

  ```c++
  std::string json_str = params2json::make_message(params2json::func_s(param_0, param_1));
  ```

  

- #### Add customized toJson()

  For simple types, there is already definitions of  `toJson()`, but you can also specialize it to output the customized JSON format. An example is shown below:

  ```c++
  template <>
  Json::Value toJson<bool>(const bool& value) {
      if (value)  return Json::Value("True");
      return Json::Value("False");
  }
  ```

  For complex types such as structures or classes, you have to manually define the `toJson()` function since the member name information is lost during compilation. Here's an example of how to do it:

  ```c++
  struct simple {
      int num;
      bool flag;
  };
  
  struct complex {
      int num;
      simple struct_member;
  };
  
  template<>
  Json::Value toJson<simple>(const simple& obj) {
      Json::Value value;
      value["num"] = toJson(obj.num);
      value["flag"] = toJson(obj.flag);
      return value;
  }
  
  template<>
  Json::Value toJson<complex>(const complex& obj) {
      Json::Value value;
      value["num"] = toJson(obj.num);
      value["struct_member"] = toJson(obj.struct_member);
      return value;
  }
  ```

  You can turn to `src\example.cpp` to check more details.

- #### Add customized make_message()

  `make_message()` is a method that converts a `Json::Value` object to a `std::string` using `Json::StreamWriter`. If you need a more customized approach, you can overload `make_message()`.
  
  Alternatively, you can directly obtain the `Json::Value` object using `toJson(func_s())` and process it in a customized way.

  
